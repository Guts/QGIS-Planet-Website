---
source: "blog"
title: "Managing Legacy Code - PyConID 2023"
date: "2023-12-01T00:00:00"
link: "https://kartoza.com/pyconid-2023-in-bandung-indonesia"
draft: "false"
showcase: "planet"
subscribers: ["kartoza"]
author: "Kartoza"
tags: []
languages: ["en_gb"]
available_languages: ["en_gb"]
---

<div class="ql-editor read-mode"><p>On November 18-19th&nbsp;2023, Python ID (Indonesia)&nbsp;held PyCon ID 2023&nbsp;in Bina Nusantara (Binus) University Bandung. I attended with my colleague from the Python ID Yogyakarta region.</p><p><img src="https://kartoza.com/files/RqXyZ7Z.jpg" /></p><p><br /></p><p>This is the 6<sup>th</sup>&nbsp;PyCon in Indonesia and the first hybrid&nbsp;PyCon post pandemic. The general theme was “Python Is Fun”. This year, PyCon ID presented three keynote talks, 39 regular talks, three workshops and eight lightning talks, with 654 total participants. At the closing ceremony, Python ID announced that they will host PyCon APAC (Asia-Pacific) 2024 in Yogyakarta, October 25-27<sup>th</sup>&nbsp;2024.</p><p><br /></p><p>One of the keynote sessions was from Giovanni Sakti Nugraha, a tech advisor who was leading the Infrastructure Engineering Function at GoPay, one of the biggest fintech startup in South-East Asia. The talk, 'Becoming a Skilled Diver', uncovered approaches to adeptly navigate and understand code written by others.</p><p><img src="https://kartoza.com/files/9ZrNfm6.png" /></p><p><br /></p><p>Gio said that based on the growth of the software industry in Indonesia, which is between two to four times over the past ten years, there is no a great deal legacy code in Indonesia. He defines legacy code as code that cannot be run or developed further without additional effort to understand, fetch dependencies and implement harnesses or safety measures.</p><p><br /></p><p>This topic about legacy code is relevant to Python, as Python will be the largest producer of legacy code for this decade, due to being one of the most popular programming languages (at least number two, depending on what ranking source is referenced).</p><p><br /></p><p>When working on the legacy code, we need to understand that code is fragile. Some of the reference we can use are:</p><ol><li><span class="ql-ui" contenteditable="false"></span><strong>Working Effectively with Legacy Code by Michael C. Feathers.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong>Refactoring by Martin Fowler.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(0, 0, 255);"><u><a href="https://producingoss.com" rel="noopener noreferrer">https://producingoss.com/</a></u></strong><strong>&nbsp;website.</strong></li></ol><p><br /></p><p>Gio mentioned that inspiration for maintaining legacy source can be taken from open source projects and their communities.</p><p><br /></p><p>From those references, there are few key points to handle code:</p><ol><li><span class="ql-ui" contenteditable="false"></span><strong>Be hyper aware.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>Understand the code so when we change something, we know which parts will be affected.</li><li><span class="ql-ui" contenteditable="false"></span><strong>Be specific when making changes.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>Focus on the scope. When we intend to work on part A for example, focus on that, even though we might find other parts that also need updating. Failing to do this will turn an initially simple PR into a big one.</li><li><span class="ql-ui" contenteditable="false"></span><strong>Preserve signatures.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>When changing a method signature or type, be really careful. Many parts could be affected; moreover in an interpreted language like Python, if the tests do not cover that, this could cause issues later on.</li><li><span class="ql-ui" contenteditable="false"></span><strong>Rely on the compiler.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>This is not applicable to Python since it is an interpreted language, which decreases our chance of making our code safe by at least 50%.</li><li><span class="ql-ui" contenteditable="false"></span><strong>Rely on the harness.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>A harness is a safety measure to make sure our code still works and behaves as expected with our refactoring.</li><li><span class="ql-ui" contenteditable="false"></span><strong>Pair or mob as required.</strong></li><li class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>If it’s difficult work, do not hesitate to ask for help.</li></ol><p><br /></p><p>One trait of a good code is that the dependencies should be easy to understand. We can make our code like this, to make it easy to understand:</p><ol><li><span class="ql-ui" contenteditable="false"></span><strong>Familiar.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong>Repeating patterns.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong>Decision journeys well-documented.</strong></li></ol><p><br /></p><p>At the end of the session, Gio summarised what we can do to “make legacy code not legacy code anymore”.</p><ol><li><span class="ql-ui" contenteditable="false"></span><strong>Up-to-date docs, standard practices, proper use of patterns.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong>Use of dependencies that are well supported.</strong></li><li><span class="ql-ui" contenteditable="false"></span><strong>Code that is well-covered with tests with proper SoC (separation of concerns).</strong></li></ol></div>
